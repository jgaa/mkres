
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <ranges>
#include <algorithm>
#include <set>
#include <format>
#include <regex>

#include "gzipranges.hpp"

#include <boost/program_options.hpp>

#ifdef MKRES_WITH_GZIP
#   include<zlib.h>
#endif

using namespace std;
using namespace std::string_literals;

namespace mkres {

using path_t = filesystem::path;

template <class T, class V>
concept range_of = std::ranges::range<T> && std::is_same_v<V, std::ranges::range_value_t<T>>;

template <class T, class V>
concept input_range_of = std::ranges::input_range<T> && std::is_same_v<V, std::ranges::range_value_t<T>>;

struct Config {
    bool verbose = false;
    bool recurse = false;

    string res_name = "EmbeddedResource";
    std::string ns = "mkres";
    std::string filter;
    std::string exclude;
    std::string compression = "none";

    path_t destination = "out";
    vector<path_t> sources;
};

// Formats one input stream to a span of bytes;

void format_data(ostream& out, input_range_of<byte> auto& in) {

    string_view seperator;
    auto col = 0;

    out << "{";

    for(const auto& b : in) {
        const auto ch = to_integer<uint8_t>(b);
        out << format("{}b({:0>2x})", seperator, ch);
        seperator = ",";

        if (++col > 20) {
            out << endl;
            col = 0;
        }
    }

    out << "}";
}

void generate(const Config& config,
              const range_of<pair<filesystem::path /* input path */, string  /* name/key */>> auto& inputs) {
    const auto ns = config.ns;
    const auto hdr_name = config.destination.string() + ".h";
    const auto hdr_name_tmp = hdr_name + "~";
    const auto impl_name = config.destination.string() + ".cpp";
    const auto impl_name_tmp = impl_name + "~";
    const auto res_name = config.res_name;
    const bool is_compressed = config.compression == "gzip";
    const auto compressed = is_compressed ? "true" : "false";

    ofstream impl(impl_name_tmp);
    ofstream hdr(hdr_name_tmp);
    //int count = 0;

    // Generate a simple header file

    hdr << format(R"(
// Generated by mkres version {}
// See: https://github.com/jgaa/mkres

#pragma once
#include <cstddef>
#include <span>
#include <string_view>
#include <string>
namespace {} {{

class {} {{
public:
    struct Data {{
        const std::span<const std::byte> data;
        const size_t origLen{{}};

        bool empty() const noexcept {{
            return data.empty();
        }}

        // Gets the entire buffer. Decompresses the data if it's compressed.
        std::string toString() const;
    }};

    static const Data& get(std::string_view key) noexcept;

    static constexpr bool isCompressed() noexcept {{
        return {};
    }}

    static constexpr std::string_view compression() noexcept {{
        return "{}";
    }}
}};
}} // namespace

)", MKRES_VERSION_STR, ns, res_name, compressed, config.compression);

    // Generate the implemetation file

/// =============================================================
/// Start of implementation


    if (is_compressed) {
        impl << R"(
#ifndef ZLIB_CONST
#   define ZLIB_CONST
#endif
#include <zlib.h>
#include <cassert>
#include <stdexcept>
#include <cstdint>
#include <format>

)";
    }
    impl << format(R"(

#include <algorithm>
#include "{}"

namespace {} {{

namespace {{
)", hdr_name, ns);

if (is_compressed) {
    impl << R"(
/*! Uncompress the entire compressed data from one input buffer to one output buffer of sufficcient size
 *
 *  Returns a span over the uncompressed data.
 */

template <typename In, typename Out>
auto gz_uncompress_all(const In& in, Out& out) {

    z_stream strm{};

    const auto wsize = MAX_WBITS | 16;

    if (inflateInit2(&strm, wsize) != Z_OK) {
        throw std::runtime_error{"Failed to initialize decompression"};
    }

    strm.avail_in = in.size();
    strm.next_in = reinterpret_cast<const Bytef *>(in.data());

    strm.avail_out = out.size();
    strm.next_out = reinterpret_cast<Bytef *>(out.data());

    const auto result = inflate(&strm, Z_FINISH);
    if (result != Z_STREAM_END) {
        throw std::runtime_error{std::format("Failed to decompress. Error {}", result)};
    }

    return std::span{out.data(), strm.total_out};
})";
}

    impl << R"(

// Actual data
// (In their infinite wisdom, the C++ committee has decided that a container with std::byte cannot
//  be initialized with an initializer-list of chars or integers - each byte must be individually
//  constructed.)
#define b(ch) std::byte{0x ## ch}

)";

/// =============================================================
/// Data
///

    using formatter_t = function<void(ostream&, path_t)>;

    formatter_t formatter = [&config](ostream& out, const path_t& path) {

        ifstream data_stream(path, ios_base::in | ios_base::binary);
        data_stream.unsetf(ios_base::skipws);

        // compress ?

        auto input_range = ranges::istream_view<char>{data_stream}
                           | ranges::views::transform([](const auto ch) {
                                 return byte{static_cast<uint8_t>(ch)};
                             });

        out << " // " << path << endl;

        if (config.compression == "gzip") {
            auto compressor = jgaa::ranges::zlib::gz_compressor<decltype(input_range)>(input_range);
            format_data(out, compressor);
        } else {
            format_data(out, input_range);
        }
    };

    string_view delimiter;

    std::vector<std::tuple<string_view /* key */,
                           string /* var_name */,
                           size_t /* orig size */>> data_names;

    // First, make one array for each file.
    // I have not found a simple constexpr construct to put it directly in the data array

    size_t count = 0;
    for (const auto& [data_path, key] : inputs) {

        auto name = format("data_{}", ++count);

        impl << format(R"(constexpr auto {} = std::to_array<const std::byte>()", name);
        formatter(impl, data_path);
        impl << ");" << endl;

        data_names.emplace_back(key, name, filesystem::file_size(data_path));
    }

    impl << format(R"(

#undef b

using data_t = std::pair<std::string_view, {}::Data>;
constexpr auto data = std::to_array<data_t>({{)", res_name);

    delimiter = {};
    // Now, put the data-elements in an array so we can look it up from a key
    for(const auto& [key, name, len] : data_names) {
        impl << format(R"({}
    {{"{}", {{{}, {}}}}})", delimiter, key, name, len);
        delimiter = ", ";
    }

    impl << "});" << endl;

/// =============================================================
/// Methods

impl << format(R"(

}} // anon namespace

const {}::Data& {}::get(std::string_view key) noexcept {{

    // C++20 dont't have an algorithm to search for a value in a sorted range.
    const data_t target{{key, {{}}}};
    const auto range = std::ranges::lower_bound(data, target, [](const auto& left, const auto& right) {{
        return left.first < right.first;
    }});

    if (range != data.end() && range->first == key) {{
        return range->second;
    }}

    static constexpr data_t empty;

    return empty.second;
}} // get()


std::string {}::Data::toString() const {{
)", res_name, res_name, res_name);

    if (is_compressed) {
    impl << R"(
    if (isCompressed()) {
        std::string out_buffer;
        out_buffer.resize(origLen);
        std::span<std::byte> out{reinterpret_cast<std::byte *>(out_buffer.data()), out_buffer.size()};
        gz_uncompress_all(data, out);
        return out_buffer;
    }
)";
    }
    impl << R"(
    const char *ptr = reinterpret_cast<const char *>(data.data());
    std::string str{ptr, data.size()};
    return str;
}
} // namespace
)";

    impl.close();
    hdr.close();

    std::filesystem::rename(hdr_name_tmp, hdr_name);
    std::filesystem::rename(impl_name_tmp, impl_name);
}

class Scanner {
    using inputs_t = set<path_t>;
public:
    using named_inputs_t = map<path_t, vector<path_t>>;

    Scanner(const Config& conf)
        : conf_{conf} {

        auto apply = [&](auto& cfg, auto & var, const auto& name) {
            if (!cfg.empty()) {
                clog << "Applying " << name << ": " << cfg << endl;
                var.emplace(cfg);
            }
        };

        apply(conf_.filter, filter_, "filter");
        apply(conf_.exclude, exclude_, "negative filter (exclude)");
    }

    auto scan() {
        for(const auto& path : conf_.sources) {
            if (filesystem::is_directory(path)) {
                if (conf_.recurse) {
                    scanDir(path.parent_path(), path.filename());
                } else {
                    throw runtime_error{format(R"(The path "{}" is a directory! Use "--recurse" option to scan directories.)", path.string())};
                }
            } else {
                add(path.parent_path(), path.filename());
            }
        }

        return toRange();
    }

    auto count() const noexcept {
        return inputs_.size();
    }

private:
    void scanDir(const path_t& root, const path_t& path) {
        auto scan_path = root;
        scan_path /= path;

        if (conf_.verbose) {
            clog << "Scanning directory: " << scan_path << endl;
        }

        for(const auto& item : filesystem::directory_iterator{scan_path}) {
            const auto branch = item.path().filename();
            auto full_path = scan_path;
            full_path /= branch;

            auto relative_path = path;
            relative_path /= branch;

            if (filesystem::is_directory(full_path)) {
                scanDir(root, relative_path);
                continue;
            }

            add(root, relative_path);
        }
    }

    void add(const path_t& root, const path_t& path) {
        auto full_path = root;
        full_path /= path;

        const auto filtered = [&](const regex& filter, const auto& path) {
            if (regex_match(path.string(), filter)) {
                return true;
            }
            return false;
        };

        if ((filter_ && !filtered(*filter_, path))
            || (exclude_ && filtered(*exclude_, path))) {
            if (conf_.verbose) {
                clog << "- excluding: " << full_path << " (filter)" << endl;
            }
            return;
        }

        if (filesystem::is_regular_file(full_path)) {
            if (conf_.verbose) {
                clog << "Adding : " << full_path  << " as --> " << path << endl;
            }

            auto [_, added] = inputs_.emplace(full_path);
            if (added) {

                auto [_, added] = names_.emplace(path);
                if (!added) {
                    throw runtime_error{format(R"(The relative name "{}" in path "{}" was already used by another file. Relative paths are used as keys and must be unique!)",
                                               path.string(), root.string())};
                }

                named_inputs_[root].emplace_back(path);
            }
        } else {
            if (!filesystem::exists(full_path)) {
                throw runtime_error{format(R"(File or directory not found: "{}")", path.string())};
            }
            cerr << "*** Ignoring non-regular file: " << path << endl;
        }
    }

    vector<pair<path_t, string>> toRange() const {
        vector<pair<path_t, string>> inputs;
        for(const auto& [root, targets] : named_inputs_) {
            for(const auto& target : targets) {
                auto full_path = root;
                full_path /= target;
                inputs.emplace_back(full_path, target.string());
            }
        }

        ranges::sort(inputs, [](const auto& left, const auto& right) {
            return left.second < right.second;
        });
        return inputs;
    }

    const Config& conf_;
    inputs_t inputs_;
    inputs_t names_;
    named_inputs_t named_inputs_;
    optional<regex> filter_;
    optional<regex> exclude_;
};


} // namespace mkres


int main(const int argc, const char **argv) {
    namespace po = boost::program_options;
    po::options_description general("Options");
    mkres::Config config;
    bool help = false;
    bool version = false;

    general.add_options()
        ("help,h", po::bool_switch(&help), "Print help and exit")
        ("version", po::bool_switch(&version), "print version information and exit")
        ("verbose,v", po::bool_switch(&config.verbose),
         "Be verbose about what's being done")
        ("recurse,r", po::bool_switch(&config.recurse),
         "Recurse into directories")
        ("filter",
         po::value(&config.filter)->default_value(config.filter),
         "Filter the file-names to embed (regex)")
        ("exclude",
         po::value(&config.exclude)->default_value(config.exclude),
         "Exclude the the file-names to embed (regex)")
        ("destination,d",
         po::value(&config.destination)->default_value(config.destination),
         "Destination path/name. '.h' and '.cpp' is added to the destination file names, so just specify the name without extention.")
        ("compression,c",
          po::value(&config.compression)->default_value(config.compression),
         "Compression to use. 'none' or 'gzip'. If compressed, the application must decompress the data before it can be used.")
        ("namespace,n",
         po::value(&config.ns)->default_value(config.ns),
         "C++ Namespace to use for the embedded resource(s)")
        ("name,N",
         po::value(&config.res_name)->default_value(config.res_name),
         "Resource-name. This is the static constexpr name for the resource that you call from your code.")
        ;


    po::options_description source_files("hidden");
    source_files.add_options()
        ("input-files", po::value(&config.sources), "Input file or directory")
        ;

    po::positional_options_description input;
    input.add
        ("input-files", -1)
        ;

    const auto appname = filesystem::path(argv[0]).stem().string();
    po::options_description cmdline_options;
    cmdline_options.add(general).add(source_files);
    po::variables_map vm;
    try {
        po::store(po::command_line_parser(argc, argv).options(cmdline_options).positional(input).run(), vm);
        po::notify(vm);
    } catch (const std::exception& ex) {
        cerr << appname
             << " Failed to parse command-line arguments: " << ex.what() << endl;
        return -1;
    }

    if (help) {
        cout << appname << " [options] input-file ..." << endl;
        cout << general << endl;
        return -2;
    }

    if (version) {
        cout << appname << ' ' << MKRES_VERSION_STR << endl;
        return -3;
    }

    try {
        mkres::Scanner scanner{config};
        auto inputs = scanner.scan();
        clog << "Got " << scanner.count() << " items " << endl;
        generate(config, inputs);
    } catch(const exception& ex) {
        cerr << "Failed with exception! Message:  " << ex.what() << endl;
    }
}
