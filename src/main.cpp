
#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <filesystem>
#include <ranges>
#include <algorithm>
#include <set>
#include <format>
#include <regex>

#include <boost/program_options.hpp>

using namespace std;
using namespace std::string_literals;

namespace mkres {

using path_t = filesystem::path;

template <class T, class V>
concept range_of = std::ranges::range<T> && std::is_same_v<V, std::ranges::range_value_t<T>>;

struct Config {
    bool verbose = false;
    bool recurse = false;

    string res_name = "EmbeddedResource";
    std::string ns = "mkres";
    std::string filter;
    std::string compression = "none";

    path_t destination = "out";
    vector<path_t> sources;
};

template <typename T>
string gen_keys(const T& input) {

    std::ostringstream out;
    string_view seperator = "    ";

    for(const auto& [_, key] : input) {
        out << format(R"({}"{}")", seperator, key);
        seperator = ",\n    ";

    }

    return out.str();
}

// Formats one input stream to a span of bytes;

void format_data(ostream& out, range_of<byte> auto& in) {

    string_view seperator;
    auto col = 0;

    out << "{";

    for(const auto& b : in) {
        const auto ch = to_integer<uint8_t>(b);
        out << format("{}std::byte{{0x{:x}}}", seperator, ch);
        seperator = ",";

        if (++col > 20) {
            out << endl;
            col = 0;
        }
    }

    out << "}";
}



void generate(const Config& config,  const range_of<pair<filesystem::path /* input path */, string  /* name/key */>> auto& inputs) {
    const auto ns = config.ns;
    const auto hdr_name = config.destination.string() + ".h";
    const auto impl_name = config.destination.string() + ".cpp";
    const auto res_name = config.res_name;
    const auto compressed = config.compression == "gzip" ? "true" : "false";

    ofstream impl(impl_name);
    ofstream hdr(hdr_name);
    //int count = 0;

    // Generate a simple header file

    hdr << format(R"(
// Generated by mkres version {}
// See: https://github.com/jgaa/mkres

#pragma once
#include <cstddef>
#include <span>
#include <string_view>
namespace {} {{

class {} {{
public:
    struct Data {{
        std::span<const std::byte> data;
    }};

    static Data get(std::string_view key) noexcept;
}};
}} // namespace

)", MKRES_VERSION_STR, ns, res_name);

    // Generate the implemetation file

/// =============================================================
/// Start of implementation

    impl << format(R"(
#include "{}"

namespace {} {{

namespace {{

// Index (keys)
constexpr auto keys = std::to_array<std::string_view>({{
{}
}});

// Actual data
)", hdr_name, ns,  gen_keys(inputs));

/// =============================================================
/// Data

    using formatter_t = function<void(ostream&, path_t)>;

    formatter_t formatter = [](ostream& out, const path_t& path) {

        ifstream data_stream(path, ios_base::in | ios_base::binary);

        // compress ?

        auto input_range = ranges::istream_view<uint8_t>{data_stream}
                           | ranges::views::transform([](const auto ch) {
                                 return byte(ch);
                             });

        out << " // " << path << endl;
        format_data(out, input_range);
    };

    string_view delimiter;

    std::vector<string> data_names;

    // First, make one array for each file.
    // I have not found a simple constexpr construct to put it directly in the data array

    size_t count = 0;
    for (const auto& [data, _] : inputs) {

        auto name = format("data_{}", ++count);

        impl << format(R"(constexpr auto {} = std::to_array<const std::byte>()", name);
        formatter(impl, data);
        impl << ");\n";

        data_names.emplace_back(name);
    }

    impl << format(R"(
constexpr auto data = std::to_array<{}::Data>({{)", res_name);

    delimiter = {};
    // Now, put the data-elements in an array so we can look it up from an index value
    for(const auto& name : data_names) {
        impl << format(R"({}
    {{{}}})", delimiter, name);
        delimiter = ", ";
    }

    impl << "});" << endl;

/// =============================================================
/// Methods

impl << format(R"(
}} // anon namespace

{}::Data {}::get(std::string_view key) noexcept {{

    return {{}};
}} // get()

}} // namespace
)", res_name, res_name);

}

class Scanner {
    using inputs_t = set<path_t>;
public:
    using named_inputs_t = map<path_t, vector<path_t>>;

    Scanner(const Config& conf)
        : conf_{conf} {
        if (!conf_.filter.empty()) {
            if (conf_.verbose) {
                clog << "Applying filter: " << conf.filter << endl;
            }
            filter_.emplace(conf_.filter);
        }
    }

    auto scan() {
        for(const auto& path : conf_.sources) {
            if (filesystem::is_directory(path)) {
                if (conf_.recurse) {
                    scanDir(path.parent_path(), path.filename());
                } else {
                    throw runtime_error{format(R"(The path "{}" is a directory! Use "--recursive" option to scan directories.)", path.string())};
                }
            } else {
                add(path.parent_path(), path.filename());
            }
        }

        return toRange();
    }

    auto count() const noexcept {
        return inputs_.size();
    }

private:
    void scanDir(const path_t& root, const path_t& path) {
        auto scan_path = root;
        scan_path /= path;

        if (conf_.verbose) {
            clog << "Scanning directory: " << scan_path << endl;
        }

        for(const auto& item : filesystem::directory_iterator{scan_path}) {
            const auto branch = item.path().filename();
            auto full_path = scan_path;
            full_path /= branch;

            auto relative_path = path;
            relative_path /= branch;

            if (filesystem::is_directory(full_path)) {
                scanDir(root, relative_path);
                continue;
            }

            add(root, relative_path);
        }
    }

    void add(const path_t& root, const path_t& path) {
        auto full_path = root;
        full_path /= path;

        if (filter_) {
            if (!regex_match(path.string(), *filter_)) {
                if (conf_.verbose) {
                    clog << "- excluding: " << full_path << " (filter)" << endl;
                }
                return;
            }
        }

        if (filesystem::is_regular_file(full_path)) {
            if (conf_.verbose) {
                clog << "Adding : " << full_path  << " as --> " << path << endl;
            }

            auto [_, added] = inputs_.emplace(full_path);
            if (added) {

                auto [_, added] = names_.emplace(path);
                if (!added) {
                    throw runtime_error{format(R"(The relative name "{}" in path "{}" was already used by another file. Relative paths are used as keys and must be unique!)",
                                               path.string(), root.string())};
                }

                named_inputs_[root].emplace_back(path);
            }
        } else {
            if (!filesystem::exists(full_path)) {
                throw runtime_error{format(R"(File or directory not found: "{}")", path.string())};
            }
            cerr << "*** Ignoring non-regular file: " << path << endl;
        }
    }

    vector<pair<path_t, string>> toRange() const {
        vector<pair<path_t, string>> inputs;
        for(const auto& [root, targets] : named_inputs_) {
            for(const auto& target : targets) {
                auto full_path = root;
                full_path /= target;
                inputs.emplace_back(full_path, target.string());
            }
        }

        ranges::sort(inputs, [](const auto& left, const auto& right) {
            return left.second < right.second;
        });
        return inputs;
    }

    const Config& conf_;
    inputs_t inputs_;
    inputs_t names_;
    named_inputs_t named_inputs_;
    optional<regex> filter_;
};


} // namespace mkres


int main(const int argc, const char **argv) {
    namespace po = boost::program_options;
    po::options_description general("Options");
    mkres::Config config;
    bool help = false;
    bool version = false;

    general.add_options()
        ("help,h", po::bool_switch(&help), "Print help and exit")
        ("version", po::bool_switch(&version), "print version information and exit")
        ("verbose,v", po::bool_switch(&config.verbose),
         "Be verbose about what's being done")
        ("recurse,r", po::bool_switch(&config.recurse),
         "Recurse into directories")
        ("filter",
         po::value(&config.filter)->default_value(config.filter),
         "Filter the file-names to embed (regex)")
        ("destination,d",
         po::value(&config.destination)->default_value(config.destination),
         "Destination path/name. '.h' and '.cpp' is added to the destination file names, so just specify the name without extention.")
        ("compression,c",
          po::value(&config.compression)->default_value(config.compression),
         "Compression to use. 'none' or 'gzip'. If compressed, the application must decompress the data before it can be used.")
        ("namespace,n",
         po::value(&config.ns)->default_value(config.ns),
         "C++ Namespace to use for the embedded resource(s)")
        ("name,N",
         po::value(&config.res_name)->default_value(config.res_name),
         "Resource-name. This is the static constexpr name for the resource that you call from your code.")
        ;


    po::options_description source_files("hidden");
    source_files.add_options()
        ("input-files", po::value(&config.sources), "Input file or directory")
        ;

    po::positional_options_description input;
    input.add
        ("input-files", -1)
        ;

    const auto appname = filesystem::path(argv[0]).stem().string();
    po::options_description cmdline_options;
    cmdline_options.add(general).add(source_files);
    po::variables_map vm;
    try {
        po::store(po::command_line_parser(argc, argv).options(cmdline_options).positional(input).run(), vm);
        po::notify(vm);
    } catch (const std::exception& ex) {
        cerr << appname
             << " Failed to parse command-line arguments: " << ex.what() << endl;
        return -1;
    }

    if (help) {
        cout << appname << " [options] input-file ..." << endl;
        cout << general << endl;
        return -2;
    }

    if (version) {
        cout << appname << ' ' << MKRES_VERSION_STR << endl;
        return -3;
    }

    try {
        mkres::Scanner scanner{config};
        auto inputs = scanner.scan();
        clog << "Got " << scanner.count() << " items " << endl;
        generate(config, inputs);
    } catch(const exception& ex) {
        cerr << "Failed with exception! Message:  " << ex.what() << endl;
    }
}
